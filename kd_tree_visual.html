<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <title>2-D 树可视化</title>
    <style>
        :root {
            --bg-color: #f0f2f5;
            --primary-color: #2563eb;
            --node-color: #ffffff;
            --node-stroke: #334155;
            --link-color: #94a3b8;
            --highlight: #ef4444;
            --split-x: #2563eb;
            --split-y: #10b981;
            --splitter-color: #e2e8f0;
        }
        body { font-family: 'Segoe UI', system-ui, sans-serif; margin: 0; background: var(--bg-color); height: 100vh; display: flex; flex-direction: column; overflow: hidden; }
        
        /* 顶部工具栏 */
        .toolbar {
            background: #1e293b; color: white; padding: 12px 20px;
            display: flex; gap: 10px; align-items: center; box-shadow: 0 2px 10px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .toolbar input { border-radius: 4px; border: 1px solid #475569; padding: 6px 10px; width: 60px; outline: none; }
        .toolbar button { 
            background: var(--primary-color); color: white; border: none; padding: 7px 14px; 
            border-radius: 4px; cursor: pointer; font-size: 14px; transition: background 0.2s;
        }
        .toolbar button:hover { background: #1d4ed8; }
        .toolbar .selected-info { margin-left: 20px; color: #fbbf24; font-weight: bold; font-size: 14px; }

        /* 主容器 */
        .main-container { display: flex; flex: 1; overflow: hidden; position: relative; }

        /* 左侧面板 */
        .plot-container {
            width: 450px; min-width: 300px; max-width: 800px; padding: 20px; background: white;
            display: flex; flex-direction: column; align-items: center; flex-shrink: 0;
        }
        #plotSvg { background: #f8fafc; border: 1px solid #cbd5e1; cursor: crosshair; flex-shrink: 0; }

        /* 动态分割条 */
        .splitter {
            width: 6px; cursor: col-resize; background-color: var(--splitter-color);
            transition: background-color 0.2s; flex-shrink: 0;
        }
        .splitter:hover { background-color: var(--primary-color); }

        /* 右侧面板 */
        #viewport { flex: 1; overflow: auto; background-color: #f8fafc; position: relative; cursor: grab; }
        #viewport:active { cursor: grabbing; }
        #canvas-container { width: 5000px; height: 3000px; position: relative; }
        
        /* 元素样式 */
        .kd-node-rect { fill: var(--node-color); stroke: var(--node-stroke); stroke-width: 2px; transition: all 0.2s; cursor: pointer; }
        .kd-node-rect.selected { stroke: var(--highlight); stroke-width: 4px; fill: #fee2e2; }
        .node-text { font-size: 12px; font-weight: 600; text-anchor: middle; pointer-events: none; }
        .axis-label { font-size: 10px; fill: #64748b; font-weight: bold; pointer-events: none; }
        .link { stroke: var(--link-color); stroke-width: 1.5px; fill: none; }
        
        .plot-point { fill: var(--node-stroke); stroke: white; stroke-width: 1.5px; cursor: pointer; }
        .plot-point.selected { fill: var(--highlight); r: 6; }
        .plot-label { font-size: 10px; fill: #1e293b; font-weight: 500; text-anchor: middle; }
        .plot-line { stroke-width: 1.5px; stroke-dasharray: 4; opacity: 0.4; pointer-events: none; }
        .plot-line.selected { stroke-width: 3px; stroke-dasharray: none; opacity: 1; }

        #viewport.dragging * {
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
        }
    </style>
</head>
<body>

    <div class="toolbar">
        <strong>2-D 树可视化</strong>
        <span style="border-left: 1px solid #475569; height: 20px; margin: 0 10px;"></span>
        X: <input type="number" id="inputX" value="50">
        Y: <input type="number" id="inputY" value="50">
        <button onclick="uiInsert()">插入点</button>
        <span style="border-left: 1px solid #475569; height: 20px; margin: 0 10px;"></span>
        <div id="selectedLabel" class="selected-info">选中: 无</div>
        <span style="border-left: 1px solid #475569; height: 20px; margin: 0 10px;"></span>
        <button id="btnDelete" onclick="uiDelete()" style="background:var(--highlight); display:none;">删除选中</button>
        <button onclick="uiClear()" style="background:#64748b">清空</button>
    </div>

    <div class="main-container">
        <div class="plot-container" id="leftPane">
            <h4 style="margin:0 0 10px 0">2D 空间视图 [100x100]</h4>
            <svg id="plotSvg" width="400" height="400">
                <g id="plotLines"></g>
                <g id="plotPoints"></g>
                <g id="plotLabels"></g>
            </svg>
        </div>

        <div class="splitter" id="dragSplitter"></div>

        <div id="viewport">
            <div id="canvas-container">
                <svg id="treeSvg" width="5000" height="3000">
                    <g id="linksGroup"></g>
                    <g id="nodesGroup"></g>
                </svg>
            </div>
        </div>
    </div>

    <script>
        /** KD树 **/
        let selectedId = null;

        class KDNode {
            constructor(point, axis, bounds) {
                this.point = point;
                this.axis = axis;
                this.left = null;
                this.right = null;
                this.bounds = bounds;
                this.id = "n" + Math.random().toString(36).substr(2, 9);
                this.x = 0; this.y = 0;
            }
        }

        class KDTree {
            constructor() { this.root = null; }

            insert(point) {
                const rec = (node, pt, depth, bnd) => {
                    if (!node) return new KDNode(pt, depth % 2, bnd);
                    const ax = node.axis;
                    const nb = [...node.bounds];
                    if (pt[ax] < node.point[ax]) {
                        nb[ax * 2 + 1] = node.point[ax];
                        node.left = rec(node.left, pt, depth + 1, nb);
                    } else {
                        nb[ax * 2] = node.point[ax];
                        node.right = rec(node.right, pt, depth + 1, nb);
                    }
                    return node;
                };
                this.root = rec(this.root, point, 0, [0, 100, 0, 100]);
            }

            findMin(node, dim, depth) {
                if (!node) return null;
                const cd = depth % 2;
                if (cd === dim) {
                    return node.left ? this.findMin(node.left, dim, depth + 1) : node;
                }
                const lRes = this.findMin(node.left, dim, depth + 1);
                const rRes = this.findMin(node.right, dim, depth + 1);
                let min = node;
                if (lRes && lRes.point[dim] < min.point[dim]) min = lRes;
                if (rRes && rRes.point[dim] < min.point[dim]) min = rRes;
                return min;
            }

            delete(node, point, depth) {
                if (!node) return null;
                const cd = depth % 2;
                if (node.point[0] === point[0] && node.point[1] === point[1]) {
                    if (node.right) {
                        const min = this.findMin(node.right, cd, depth + 1);
                        node.point = [...min.point];
                        node.right = this.delete(node.right, min.point, depth + 1);
                    } else if (node.left) {
                        const min = this.findMin(node.left, cd, depth + 1);
                        node.point = [...min.point];
                        node.right = this.delete(node.left, min.point, depth + 1);
                        node.left = null;
                    } else return null;
                    return node;
                }
                if (point[cd] < node.point[cd]) node.left = this.delete(node.left, point, depth + 1);
                else node.right = this.delete(node.right, point, depth + 1);
                return node;
            }

            updateBounds(node, bounds) {
                if (!node) return;
                node.bounds = [...bounds]; // 更新当前节点边界
                const ax = node.axis;
                const leftBounds = [...bounds];
                const rightBounds = [...bounds];
                
                // 根据当前节点的切割线，划分左右子空间的边界
                leftBounds[ax * 2 + 1] = node.point[ax];
                rightBounds[ax * 2] = node.point[ax];
                
                this.updateBounds(node.left, leftBounds);
                this.updateBounds(node.right, rightBounds);
            }
        }

        /** 布局、绘图 **/
        const tree = new KDTree();
        const RECT_W = 75, RECT_H = 36;
        const LEVEL_GAP = 90;
        const HORIZONTAL_SPACING = 550;

        function render(targetId = selectedId) {
            selectedId = targetId;
            const selNode = findById(tree.root, selectedId);
            document.getElementById('selectedLabel').innerText = selNode ? `选中: (${selNode.point})` : "选中: 无";
            document.getElementById('btnDelete').style.display = selNode ? 'inline-block' : 'none';
            
            renderPlot(selectedId);
            renderTree(selectedId);
        }

        function renderPlot(sid) {
            const lG = document.getElementById('plotLines'), pG = document.getElementById('plotPoints'), tG = document.getElementById('plotLabels');
            lG.innerHTML = ''; pG.innerHTML = ''; tG.innerHTML = '';

            const rec = (n) => {
                if (!n) return;
                const px = n.point[0] * 4, py = 400 - n.point[1] * 4;
                const [x1, x2, y1, y2] = n.bounds;

                const line = document.createElementNS("http://www.w3.org/2000/svg", "line");
                line.setAttribute("class", `plot-line ${n.id === sid ? 'selected' : ''}`);
                if (n.axis === 0) {
                    line.setAttribute("x1", px); line.setAttribute("x2", px);
                    line.setAttribute("y1", 400 - y1 * 4); line.setAttribute("y2", 400 - y2 * 4);
                    line.setAttribute("stroke", "var(--split-x)");
                } else {
                    line.setAttribute("y1", py); line.setAttribute("y2", py);
                    line.setAttribute("x1", x1 * 4); line.setAttribute("x2", x2 * 4);
                    line.setAttribute("stroke", "var(--split-y)");
                }
                lG.appendChild(line);

                const c = document.createElementNS("http://www.w3.org/2000/svg", "circle");
                c.setAttribute("cx", px); c.setAttribute("cy", py); c.setAttribute("r", 4);
                c.setAttribute("class", `plot-point ${n.id === sid ? 'selected' : ''}`);
                c.onclick = () => render(n.id);
                pG.appendChild(c);

                const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                t.setAttribute("x", px); t.setAttribute("y", py + 12);
                t.setAttribute("class", "plot-label");
                t.textContent = `${n.point[0]},${n.point[1]}`;
                tG.appendChild(t);

                rec(n.left); rec(n.right);
            };
            rec(tree.root);
        }

        function renderTree(sid) {
            const nG = document.getElementById('nodesGroup'), lG = document.getElementById('linksGroup');
            nG.innerHTML = ''; lG.innerHTML = '';
            if (!tree.root) return;

            const compute = (n, x, depth, range) => {
                if (!n) return;
                n.x = x; n.y = 60 + depth * LEVEL_GAP;
                const nextRange = range / 2;
                if (n.left) compute(n.left, x - Math.max(nextRange, 30), depth + 1, nextRange);
                if (n.right) compute(n.right, x + Math.max(nextRange, 30), depth + 1, nextRange);
            };
            compute(tree.root, 2500, 0, HORIZONTAL_SPACING);

            const draw = (n) => {
                if (!n) return;
                if (n.left) drawLink(n, n.left);
                if (n.right) drawLink(n, n.right);

                const g = document.createElementNS("http://www.w3.org/2000/svg", "g");
                const r = document.createElementNS("http://www.w3.org/2000/svg", "rect");
                r.setAttribute("x", n.x - RECT_W/2); r.setAttribute("y", n.y - RECT_H/2);
                r.setAttribute("width", RECT_W); r.setAttribute("height", RECT_H);
                r.setAttribute("rx", 8); r.setAttribute("ry", 8); // 设置圆角半径
                r.setAttribute("class", `kd-node-rect ${n.id === sid ? 'selected' : ''}`);
                r.onclick = () => render(n.id);

                const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
                t.setAttribute("x", n.x); t.setAttribute("y", n.y + 4);
                t.setAttribute("class", "node-text");
                t.textContent = n.point.join(",");

                const lbl = document.createElementNS("http://www.w3.org/2000/svg", "text");
                lbl.setAttribute("x", n.x); lbl.setAttribute("y", n.y - RECT_H/2 - 4);
                lbl.setAttribute("class", "axis-label"); lbl.setAttribute("text-anchor", "middle");
                lbl.textContent = n.axis === 0 ? "X-Split" : "Y-Split";

                g.append(r, t, lbl); nG.appendChild(g);
                draw(n.left); draw(n.right);
            };

            const drawLink = (p, c) => {
                const ln = document.createElementNS("http://www.w3.org/2000/svg", "line");
                ln.setAttribute("x1", p.x); ln.setAttribute("y1", p.y + RECT_H/2);
                ln.setAttribute("x2", c.x); ln.setAttribute("y2", c.y - RECT_H/2);
                ln.setAttribute("class", "link");
                lG.appendChild(ln);
            };
            draw(tree.root);
        }

        function findById(node, id) {
            if (!node || !id) return null;
            if (node.id === id) return node;
            return findById(node.left, id) || findById(node.right, id);
        }

        function uiInsert() {
            const x = parseInt(document.getElementById('inputX').value) || 0;
            const y = parseInt(document.getElementById('inputY').value) || 0;
            tree.insert([Math.max(0, Math.min(100, x)), Math.max(0, Math.min(100, y))]);
            render();
        }

        function uiDelete() {
            const node = findById(tree.root, selectedId);
            if (node) {
                tree.root = tree.delete(tree.root, node.point, 0);
                
                // 如果树还不为空，重新计算所有节点的空间边界
                if (tree.root) {
                    tree.updateBounds(tree.root, [0, 100, 0, 100]);
                }
                
                render(null);
            }
        }

        function uiClear() { tree.root = null; render(null); }

        /** 拖拽画布 & 分割条 **/
        const vp = document.getElementById('viewport');
        const leftPane = document.getElementById('leftPane');
        const splitter = document.getElementById('dragSplitter');

        let isViewDragging = false, startX, startY, startScrollLeft, startScrollTop;

        vp.addEventListener('mousedown', (e) => {
            if (e.target.tagName === 'rect' || e.target.tagName === 'circle') return;
            isViewDragging = true;
            startX = e.pageX;
            startY = e.pageY;
            startScrollLeft = vp.scrollLeft;
            startScrollTop = vp.scrollTop;
            vp.style.cursor = 'grabbing';
            vp.classList.add('dragging'); 
        });

        document.addEventListener('mousemove', (e) => {
            if (!isViewDragging) return;
            
            e.preventDefault(); 
            
            const dx = e.pageX - startX;
            const dy = e.pageY - startY;
            vp.scrollLeft = startScrollLeft - dx;
            vp.scrollTop = startScrollTop - dy;
        });

        document.addEventListener('mouseup', () => {
            if (isViewDragging) {
                isViewDragging = false;
                vp.style.cursor = 'grab';
                vp.classList.remove('dragging'); 
            }
        });
        
        let isResizing = false;

        splitter.addEventListener('mousedown', (e) => {
            isResizing = true;
            document.body.style.cursor = 'col-resize';
            e.preventDefault();
        });

        // 监听在document上，确保鼠标移出splitter也能继续拖动
        document.addEventListener('mousemove', (e) => {
            if (!isResizing) return;

            // 获取左侧面板相对于视口的坐标信息
            const containerRect = document.querySelector('.main-container').getBoundingClientRect();
            
            // 计算鼠标相对于容器左边缘的距离
            let newWidth = e.clientX - containerRect.left;

            // 限制最小和最大宽度
            if (newWidth < 300) newWidth = 300;
            if (newWidth > 800) newWidth = 800;

            leftPane.style.width = newWidth + 'px';
        });

        document.addEventListener('mouseup', () => {
            if (isResizing) {
                isResizing = false;
                document.body.style.cursor = 'default';
            }
        });

        window.onload = () => {
            vp.scrollLeft = (5000 - vp.clientWidth) / 2;
            render();
        };
    </script>
</body>
</html>